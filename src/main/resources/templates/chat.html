<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chat Application</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr" crossorigin="anonymous">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.1/stomp.min.js"></script>
    <style>
        :root{
          --accent: #0d6efd;
          --muted: #6c757d;
          --bubble-me: #e7f1ff;
          --bubble-other: #f8f9fa;
        }

        body, html {
          height: 100%;
          background: #fff;
        }

        .chat-shell {
          max-width: 1000px;
          margin: 1.5rem auto;
          height: calc(100vh - 3rem);
          display: grid;
          grid-template-rows: auto 1fr auto;
          gap: 0.75rem;
        }

        .chat-header {
          display:flex;
          align-items:center;
          gap:.75rem;
          padding: .75rem 1rem;
          border-radius: .5rem;
          background: linear-gradient(90deg,#fff 0%, #fbfdff 100%);
          box-shadow: 0 1px 2px rgba(16,24,40,.04);
        }

        .chat-body {
          display:flex;
          gap: 1rem;
          height: 100%;
        }

        /* messages area */
        .messages {
          flex: 1 1 0;
          border-radius:.5rem;
          padding: 1rem;
          background: #fff;
          border: 1px solid #e9ecef;
          overflow-y: auto;
          display:flex;
          flex-direction:column;
          gap:.6rem;
          min-height:0; /* allow overflow in flex */
        }

        .message-row {
          display:flex;
          gap:.75rem;
          align-items:flex-start;
        }
        .avatar {
          width:40px;height:40px;border-radius:50%;
          display:inline-flex;align-items:center;justify-content:center;
          font-weight:700;color:#fff;background:var(--muted);
          flex-shrink:0;
        }

        .bubble {
          max-width: 78%;
          padding: .5rem .75rem;
          border-radius: .6rem;
          box-shadow: 0 1px 2px rgba(16,24,40,.04);
          font-size: .95rem;
        }
        .bubble.me { background: var(--bubble-me); margin-left: auto; border-bottom-right-radius: 0.25rem; }
        .bubble.other { background: var(--bubble-other); border-bottom-left-radius: 0.25rem; }

        .meta {
          font-size: .78rem;
          color: var(--muted);
          margin-top: .2rem;
        }

        /* right column (optional) */
        .sidebar {
          width: 240px;
          border-radius:.5rem;
          padding: .75rem;
          border: 1px solid #e9ecef;
          background: #fff;
          display:flex;
          flex-direction:column;
          gap: .5rem;
        }
        .status-dot {
          width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:.5rem;
        }
        .status-online { background: #198754; }
        .status-offline { background: #adb5bd; }

        /* input bar sticky */
        .chat-input {
          display:flex;
          gap:.5rem;
          align-items:center;
          padding: .5rem;
          border-radius:.5rem;
          border: 1px solid #e9ecef;
          background: #fff;
        }
        .chat-input .form-control { height: 46px; }
        .chat-input .btn { height: 46px; }

        /* compact debug messages */
        .log-area {
          max-height: 90px;
          overflow:auto;
          font-size:.85rem;
          color:var(--muted);
          white-space:pre-wrap;
        }

        /* mobile adjustments */
        @media (max-width: 767px){
          .chat-body { flex-direction: column; }
          .sidebar { width:100%;}
        }
    </style>
</head>
<body>
<main class="chat-shell container">
    <header class="chat-header align-items-center">
        <div>
            <h2 class="h4 mb-0">Chat Application</h2>
            <small class="text-muted">Real-time chat with Spring Boot + WebSocket + STOMP</small>
        </div>

        <div class="ms-auto d-flex align-items-center gap-2">
            <span id="connectionStatus" class="badge bg-secondary">Connecting...</span>
            <button id="clearLog" class="btn btn-sm btn-outline-secondary">Clear log</button>
        </div>
    </header>

    <section class="chat-body">
        <section class="messages" id="messages" role="log" aria-live="polite" aria-atomic="false">
            <!-- messages appended here -->
        </section>

        <aside class="sidebar d-none d-md-flex">
            <div>
                <h6 class="mb-1">Status</h6>
                <div id="status" class="d-flex align-items-center">
                    <span class="status-dot status-offline" id="statusDot"></span>
                    <small id="statusText">Disconnected</small>
                </div>
            </div>

            <div>
                <h6 class="mb-1">Users</h6>
                <ul id="userList" class="list-unstyled small mb-0">
                    <li class="text-muted">No presence implemented</li>
                </ul>
            </div>
        </aside>
    </section>

    <form class="chat-input" id="chatForm" onsubmit="return false" aria-label="Send a message">
        <input id="senderInput" type="text" class="form-control" placeholder="Your name..." aria-label="Your name" value="User1">
        <input id="messageInput" type="text" class="form-control" placeholder="Type your message here" aria-label="Message">
        <button id="sendBtn" class="btn btn-primary" type="button" disabled>Send</button>
        <button id="clearBtn" class="btn btn-outline-secondary" type="button" title="Clear messages">Clear</button>
    </form>
</main>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.1/stomp.min.js"></script>

<script>
    // Config & state
    const ENDPOINT = '/chat';
    const SUBSCRIBE_DEST = '/topic/messages';
    const SEND_DEST = '/app/sendMessage';
    const RECONNECT_BASE = 1500;

    let stompClient = null;
    let connected = false;
    let reconnectDelayMs = RECONNECT_BASE;

    // DOM
    const messagesEl = document.getElementById('messages');
    const sendBtn = document.getElementById('sendBtn');
    const clearBtn = document.getElementById('clearBtn');
    const senderInput = document.getElementById('senderInput');
    const messageInput = document.getElementById('messageInput');
    const statusText = document.getElementById('statusText');
    const statusDot = document.getElementById('statusDot');
    const connectionStatus = document.getElementById('connectionStatus');
    const logEl = document.getElementById('log');
    const clearLogBtn = document.getElementById('clearLog');

    // Util
    function log(...args) {
      const t = new Date().toLocaleTimeString();
      const text = `[${t}] ${args.join(' ')}`;
      if (logEl) {
        logEl.textContent = (logEl.textContent ? logEl.textContent + '\n' : '') + text;
        logEl.scrollTop = logEl.scrollHeight;
      }
      console.log(...args);
    }

    function setConnected(state) {
      connected = !!state;
      sendBtn.disabled = !connected;
      if (connected) {
        connectionStatus.textContent = 'Connected';
        connectionStatus.className = 'badge bg-success';
        statusText.textContent = 'Connected';
        statusDot.className = 'status-dot status-online';
      } else {
        connectionStatus.textContent = 'Disconnected';
        connectionStatus.className = 'badge bg-secondary';
        statusText.textContent = 'Disconnected';
        statusDot.className = 'status-dot status-offline';
      }
    }

    function makeAvatar(name) {
      const initials = (name || 'U').split(' ').map(s => s[0]).join('').substring(0,2).toUpperCase();
      const bgHash = (initials.charCodeAt(0) + (initials.charCodeAt(1)||0)) % 360;
      return { initials, bg: `hsl(${bgHash} 60% 38%)` };
    }

    function appendMessage({ sender, content, ts }) {
      const me = (sender || '').toLowerCase() === (senderInput.value || 'User1').toLowerCase();
      const row = document.createElement('div');
      row.className = 'message-row';

      const avatar = document.createElement('div');
      avatar.className = 'avatar';
      const avatarMeta = makeAvatar(sender);
      avatar.textContent = avatarMeta.initials;
      avatar.style.background = avatarMeta.bg;

      const bubbleWrap = document.createElement('div');
      bubbleWrap.style.display = 'flex';
      bubbleWrap.style.flexDirection = 'column';
      bubbleWrap.style.alignItems = me ? 'flex-end' : 'flex-start';

      const bubble = document.createElement('div');
      bubble.className = 'bubble ' + (me ? 'me' : 'other');
      bubble.textContent = content;

      const meta = document.createElement('div');
      meta.className = 'meta';
      const time = new Date(ts || Date.now()).toLocaleTimeString();
      meta.textContent = `${sender || 'Anonymous'} • ${time}`;

      bubbleWrap.appendChild(bubble);
      bubbleWrap.appendChild(meta);

      if(me) {
        row.appendChild(bubbleWrap);
        row.appendChild(avatar);
      } else {
        row.appendChild(avatar);
        row.appendChild(bubbleWrap);
      }

      messagesEl.appendChild(row);
      messagesEl.scrollTo({ top: messagesEl.scrollHeight, behavior: 'smooth' });
    }

    // Connection
    function connect() {
      log('Attempting SockJS connection to', ENDPOINT);
      const socket = new SockJS(ENDPOINT);
      stompClient = Stomp.over(socket);
      stompClient.debug = (msg) => log('STOMP', msg);

      stompClient.connect({}, (frame) => {
        log('STOMP CONNECTED:', frame && frame.headers && frame.headers['version'] ? frame.headers['version'] : frame);
        setConnected(true);
        reconnectDelayMs = RECONNECT_BASE; // reset backoff

        stompClient.subscribe(SUBSCRIBE_DEST, (message) => {
          try {
            const body = JSON.parse(message.body);
            appendMessage({ sender: body.sender, content: body.content, ts: body.ts || Date.now() });
          } catch (e) {
            log('Invalid message body', e, message.body);
          }
        });

      }, (err) => {
        log('STOMP ERROR:', err && err.toString ? err.toString() : err);
        setConnected(false);
        scheduleReconnect();
      });

      socket.onclose = function(e) {
        log('SockJS closed', e && e.code ? `code=${e.code}` : e);
        setConnected(false);
        scheduleReconnect();
      };
    }

    function scheduleReconnect() {
      if (connected) return;
      log(`Reconnecting in ${reconnectDelayMs}ms...`);
      setTimeout(() => {
        log('Reconnecting now...');
        connect();
      }, reconnectDelayMs);
      reconnectDelayMs = Math.min(Math.floor(reconnectDelayMs * 1.5), 30000);
    }

    // UI actions
    function sendMessage() {
      if (!stompClient || !connected) {
        log('Not connected — cannot send.');
        return;
      }
      const sender = (senderInput.value || 'Anonymous').trim();
      const content = (messageInput.value || '').trim();
      if (!content) return;
      const payload = { sender, content, ts: Date.now() };
      try {
        stompClient.send(SEND_DEST, {}, JSON.stringify(payload));
        messageInput.value = '';
        messageInput.focus();
      } catch (e) {
        log('Send failed', e);
      }
    }

    // Events
    sendBtn.addEventListener('click', sendMessage);
    clearBtn.addEventListener('click', () => { messagesEl.innerHTML = ''; });
    clearLogBtn.addEventListener('click', () => { logEl.textContent = ''; });
    messageInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    window.addEventListener('load', () => {
      setConnected(false);
      connect();
      messageInput.focus();
    });
</script>
</body>
</html>